╔════════════════════════════════════════════════════════════════════════════╗
║                    RELATÓRIO DE REVISÃO DE ARQUIVOS                        ║
║                         BGC Analytics Project                              ║
╚════════════════════════════════════════════════════════════════════════════╝

Data: 12/10/2025 17:41:21
Sistema: Montilha
Usuário: rafae


================================================================================
ARQUIVO 1: api\main.go
================================================================================

STATUS: Arquivo encontrado
LOCALIZAÇÃO: C:\Users\rafae\OneDrive\Documentos\Projetos\Brasil Global Conect\bgc-app\api\main.go
TAMANHO: 16635 bytes
ÚLTIMA MODIFICAÇÃO: 10/05/2025 11:03:24

--------------------------------------------------------------------------------
CONTEÚDO DE api\main.go
--------------------------------------------------------------------------------
package main

import (
	"fmt"
	"crypto/rand"
	"database/sql"
	"encoding/hex"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"  // remova se nÃ£o estiver usando
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	_ "github.com/lib/pq"   // <- blank import com ESPAÃ‡O
	"gopkg.in/yaml.v3"
)

/* ===== Tipos de domÃ­nio ===== */

type MarketItem struct {
	Ano        int     `json:"ano"`
	NCMChapter string  `json:"ncm_chapter"`
	ValorUSD   float64 `json:"valor_usd"`
}

type AppConfig struct {
	ScopeChapters []string
	SOMBase       float64
	SOMAggressive float64
}

type PartnerWeights map[string]map[string]float64 // chapter -> (partner->share)

/* Tarifas (cenÃ¡rios) */
type TariffScenario struct {
	Default  map[string]float64            `yaml:"default"`
	Chapters map[string]map[string]float64 `yaml:"chapters"`
	Years    map[string]struct {
		Default  map[string]float64            `yaml:"default"`
		Chapters map[string]map[string]float64 `yaml:"chapters"`
	} `yaml:"years"`
}
type TariffScenarios struct {
	Scenarios map[string]TariffScenario `yaml:"scenarios"`
}

/* ===== Estado global ===== */

var (
	db       *sql.DB
	appCfg   AppConfig
	pweights PartnerWeights
	tariffs  TariffScenarios
)

/* ===== Utilidades ===== */

func getenv(key, def string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return def
}

func mustConnectDB() *sql.DB {
	host := getenv("DB_HOST", "db")
	port := getenv("DB_PORT", "5432")
	user := getenv("DB_USER", "bgc")
	pass := getenv("DB_PASS", "bgc")
	name := getenv("DB_NAME", "bgc")
	dsn := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable", host, port, user, pass, name)

	var conn *sql.DB
	var err error
	for i := 0; i < 30; i++ {
		conn, err = sql.Open("postgres", dsn)
		if err == nil {
			if pingErr := conn.Ping(); pingErr == nil {
				log.Printf("Connected to Postgres at %s:%s", host, port)
				return conn
			} else {
				err = pingErr
			}
		}
		log.Printf("Waiting for Postgres... (%d/30): %v", i+1, err)
		time.Sleep(2 * time.Second)
	}
	log.Fatalf("Failed to connect to DB: %v", err)
	return nil
}

func loadConfig() AppConfig {
	cfg := AppConfig{
		ScopeChapters: []string{"02", "08", "84", "85"},
		SOMBase:       0.015,
		SOMAggressive: 0.03,
	}
	if v := getenv("SCOPE_CHAPTERS", ""); v != "" {
		parts := strings.Split(v, ",")
		clean := make([]string, 0, len(parts))
		for _, p := range parts {
			p = strings.TrimSpace(p)
			if len(p) == 1 {
				p = "0" + p
			}
			if len(p) >= 2 {
				clean = append(clean, p[:2])
			}
		}
		if len(clean) > 0 {
			cfg.ScopeChapters = clean
		}
	}
	if v := getenv("SOM_BASE", ""); v != "" {
		if f, err := strconv.ParseFloat(v, 64); err == nil {
			cfg.SOMBase = f
		}
	}
	if v := getenv("SOM_AGGRESSIVE", ""); v != "" {
		if f, err := strconv.ParseFloat(v, 64); err == nil {
			cfg.SOMAggressive = f
		}
	}
	return cfg
}

func loadPartnerWeights() PartnerWeights {
	path := getenv("PARTNER_WEIGHTS_FILE", "./config/partners_stub.yaml")

	// Estrutura esperada no YAML: partners: { "<chapter|default>": { "<PAIS>": <peso float> } }
	var doc struct {
		Partners map[string]map[string]float64 `yaml:"partners"`
	}

	b, err := os.ReadFile(path)
	if err != nil {
		log.Printf("partner weights not found (%s): using defaults", path)
		return nil
	}
	if err := yaml.Unmarshal(b, &doc); err != nil {
		log.Printf("failed to parse partner weights: %v", err)
		return nil
	}
	if len(doc.Partners) == 0 {
		log.Printf("partner weights file is empty: %s", path)
		return nil
	}

	out := make(PartnerWeights) // PartnerWeights == map[string]map[string]float64

	for chapterKey, partnersMap := range doc.Partners {
		// normaliza chave do capÃ­tulo (mantÃ©m "default" como estÃ¡; capitulos "84" etc. sem mexer)
		chKey := strings.TrimSpace(chapterKey)
		if chKey != "default" && len(chKey) == 1 {
			chKey = "0" + chKey
		}

		// Cria o mapa interno para este capÃ­tulo caso ainda nÃ£o exista
		if _, ok := out[chKey]; !ok {
			out[chKey] = make(map[string]float64)
		}

		for partnerCode, weight := range partnersMap {
			p := strings.ToUpper(strings.TrimSpace(partnerCode))
			out[chKey][p] = weight // <- aqui o tipo Ã© float64, coerente com map[string]float64
		}
	}

	return out
}
func loadTariffs() {
	path := getenv("TARIFF_SCENARIOS_FILE", "./config/tariff_scenarios.yaml")
	b, err := os.ReadFile(path)
	if err != nil {
		log.Printf("tariff scenarios not found (%s): continuing without tariffs", path)
		return
	}
	if err := yaml.Unmarshal(b, &tariffs); err != nil {
		log.Printf("failed to parse tariff scenarios: %v", err)
	}
}

/* Resolve fator de tarifa (prioridade: ano.capÃ­tulo â†’ ano.default â†’ capÃ­tulo â†’ default â†’ 1.0) */
func factorFor(scn TariffScenario, year int, chapter, partner string) float64 {
	p := strings.ToUpper(partner)
	chap := chapter
	ys := fmt.Sprintf("%d", year)

	if y, ok := scn.Years[ys]; ok {
		if mp, ok := y.Chapters[chap]; ok {
			if f, ok := mp[p]; ok {
				return f
			}
		}
		if f, ok := y.Default[p]; ok {
			return f
		}
	}
	if mp, ok := scn.Chapters[chap]; ok {
		if f, ok := mp[p]; ok {
			return f
		}
	}
	if f, ok := scn.Default[p]; ok {
		return f
	}
	return 1.0
}

/* ===== Handlers ===== */

func corsMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		origin := c.GetHeader("Origin")
		if origin == "" {
			origin = "*" // quando a origem Ã© vazia (ex.: curl), tudo bem
		} else {
			// Em dev, pode liberar geral. Se preferir restringir:
			// if origin == "http://localhost:3000" { ... }
			origin = "*"
		}
		c.Header("Access-Control-Allow-Origin", origin)
		c.Header("Vary", "Origin")
		c.Header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
		c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")
		// NÃ£o vamos usar cookies -> Credenciais desabilitadas
		// c.Header("Access-Control-Allow-Credentials", "true")

		if c.Request.Method == http.MethodOptions {
			c.AbortWithStatus(204)
			return
		}
		c.Next()
	}
}

// ===== S2-16: Request ID, Logs JSON e MÃ©tricas =====

type routeMetrics struct {
	Requests     int64   `json:"requests"`
	Status2xx    int64   `json:"status_2xx"`
	Status4xx    int64   `json:"status_4xx"`
	Status5xx    int64   `json:"status_5xx"`
	SumLatencyMs int64   `json:"sum_latency_ms"`
	AvgLatencyMs float64 `json:"avg_latency_ms"`
}

var (
	metricsStart   = time.Now()
	metricsMu      sync.RWMutex
	totalRequests  int64
	statusCounters = map[int]int64{}              // ex.: 200->123, 404->7...
	byRoute        = map[string]*routeMetrics{}   // chave: "METHOD " + rota (FullPath)
)

func newReqID() string {
	b := make([]byte, 12)
	if _, err := rand.Read(b); err != nil {
		return strconv.FormatInt(time.Now().UnixNano(), 10)
	}
	return hex.EncodeToString(b)
}

// X-Request-Id: usa o header do cliente se vier, senÃ£o gera um novo
func requestIDMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		rid := c.Request.Header.Get("X-Request-Id")
		if rid == "" {
			rid = newReqID()
		}
		c.Set("req_id", rid)
		c.Writer.Header().Set("X-Request-Id", rid)
		c.Next()
	}
}

// MÃ©tricas + log estruturado (JSON)
func metricsAndLogMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		c.Next()
		latMs := time.Since(start).Milliseconds()
		status := c.Writer.Status()
		method := c.Request.Method

		route := c.FullPath()
		if route == "" {
			route = c.Request.URL.Path
		}
		key := method + " " + route

		metricsMu.Lock()
		totalRequests++
		statusCounters[status]++
		rm := byRoute[key]
		if rm == nil {
			rm = &routeMetrics{}
			byRoute[key] = rm
		}
		rm.Requests++
		rm.SumLatencyMs += latMs
		switch {
		case status >= 200 && status < 300:
			rm.Status2xx++
		case status >= 400 && status < 500:
			rm.Status4xx++
		case status >= 500:
			rm.Status5xx++
		}
		if rm.Requests > 0 {
			rm.AvgLatencyMs = float64(rm.SumLatencyMs) / float64(rm.Requests)
		}
		metricsMu.Unlock()

		// Log JSON minimalista
		rid, _ := c.Get("req_id")
		log.Printf(`{"ts":"%s","level":"info","req_id":"%v","method":"%s","path":"%s","route":"%s","status":%d,"latency_ms":%d,"ip":"%s","ua":"%s"}`,
			time.Now().Format(time.RFC3339Nano),
			rid, method, c.Request.URL.Path, route, status, latMs, c.ClientIP(), c.Request.UserAgent(),
		)
	}
}

// Handler do /metrics (snapshot em JSON)
func metricsHandler(c *gin.Context) {
	metricsMu.RLock()
	defer metricsMu.RUnlock()

	// copia defensiva para resposta
	statusByString := map[string]int64{}
	for code, cnt := range statusCounters {
		statusByString[strconv.Itoa(code)] = cnt
	}
	routesCopy := map[string]routeMetrics{}
	for k, v := range byRoute {
		routesCopy[k] = *v
	}

	c.JSON(http.StatusOK, gin.H{
		"uptime_seconds": int64(time.Since(metricsStart).Seconds()),
		"requests_total": totalRequests,
		"requests_by_status": statusByString,
		"routes": routesCopy,
	})
}

func healthHandler(c *gin.Context) {
    // opcional: checar DB rapidamente (descomente se quiser)
    // if err := db.Ping(); err != nil {
    //     c.JSON(500, gin.H{"status":"degraded","error": err.Error()})
    //     return
    // }
    c.JSON(200, gin.H{
        "select": 1,           // compat com a resposta antiga
        "status": "ok",
        "chapters_onda1":   appCfg.ScopeChapters,
        "partner_weights":  (pweights != nil),
        "tariffs_loaded":   (len(tariffs.Scenarios) > 0),
        "available_scenarios": func() []string {
            keys := make([]string, 0, len(tariffs.Scenarios))
            for k := range tariffs.Scenarios { keys = append(keys, k) }
            return keys
        }(),
    })
}


func main() {
	gin.SetMode(gin.ReleaseMode)
	appCfg = loadConfig()
	pweights = loadPartnerWeights()
	loadTariffs()

	db = mustConnectDB()
	defer db.Close()

	r := gin.Default()
	r.Use(corsMiddleware())
	r.Use(requestIDMiddleware())     // S2-16
	r.Use(metricsAndLogMiddleware()) // S2-16

	// --- ROTAS (sem duplicaÃ§Ã£o) ---
	// Health (uma vez cada; ambos usam o mesmo handler)
	r.GET("/health",  healthHandler)
	r.GET("/healthz", healthHandler)

	// MÃ©tricas (S2-16)
	r.GET("/metrics", metricsHandler)

	// OpenAPI & ReDoc
	r.GET("/openapi.yaml", func(c *gin.Context) { c.File("./openapi.yaml") })
	r.GET("/docs", func(c *gin.Context) {
		html := `<!doctype html><html><head><meta charset="utf-8"><title>BGC API Docs</title></head>
<body><redoc spec-url='/openapi.yaml'></redoc>
<script src="https://cdn.redoc.ly/redoc/latest/bundles/redoc.standalone.js"></script></body></html>`
		c.Data(200, "text/html; charset=utf-8", []byte(html))
	})

	// Endpoints analÃ­ticos
	r.GET("/market/size",    marketSizeHandler)
	r.GET("/routes/compare", routesCompareHandler)

	port := getenv("PORT", "8080")
	log.Printf("BGC API up on :%s", port)
	if err := r.Run(":" + port); err != nil {
		log.Fatal(err)
	}
}


func marketSizeHandler(c *gin.Context) {
	metric := strings.ToUpper(c.Query("metric"))
	if metric == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "metric is required [TAM|SAM|SOM]"})
		return
	}
	yearFrom, _ := strconv.Atoi(c.DefaultQuery("year_from", "2020"))
	yearTo, _ := strconv.Atoi(c.DefaultQuery("year_to", "2025"))
	ncmChapter := c.Query("ncm_chapter")
	scenario := strings.ToLower(c.DefaultQuery("scenario", "base"))

	var sb strings.Builder
	args := []any{yearFrom, yearTo}
	sb.WriteString(`SELECT ano, ncm_chapter, tam_total_usd
	                FROM v_tam_by_year_chapter
	               WHERE ano BETWEEN $1 AND $2`)
	argPos := 3

	if metric == "SAM" || metric == "SOM" {
		if len(appCfg.ScopeChapters) == 0 {
			c.JSON(500, gin.H{"error": "server misconfigured: scope chapters empty"})
			return
		}
		ph := make([]string, 0, len(appCfg.ScopeChapters))
		for range appCfg.ScopeChapters {
			ph = append(ph, fmt.Sprintf("$%d", argPos))
			argPos++
		}
		sb.WriteString(" AND ncm_chapter IN (" + strings.Join(ph, ",") + ")")
		for _, ch := range appCfg.ScopeChapters {
			args = append(args, ch)
		}
	}
	if ncmChapter != "" {
		sb.WriteString(fmt.Sprintf(" AND ncm_chapter = $%d", argPos))
		args = append(args, ncmChapter)
		argPos++
	}
	sb.WriteString(" ORDER BY ano, ncm_chapter")

	rows, err := db.Query(sb.String(), args...)
	if err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}
	defer rows.Close()

	items := make([]MarketItem, 0, 64)
	for rows.Next() {
		var mi MarketItem
		var tam float64
		if err := rows.Scan(&mi.Ano, &mi.NCMChapter, &tam); err != nil {
			c.JSON(500, gin.H{"error": err.Error()})
			return
		}
		switch metric {
		case "TAM", "SAM":
			mi.ValorUSD = tam
		case "SOM":
			switch scenario {
			case "aggressive":
				mi.ValorUSD = tam * appCfg.SOMAggressive
			default:
				mi.ValorUSD = tam * appCfg.SOMBase
			}
		default:
			c.JSON(400, gin.H{"error": "invalid metric; use TAM|SAM|SOM"})
			return
		}
		items = append(items, mi)
	}
	c.JSON(200, gin.H{"metric": metric, "scenario": scenario, "items": items})
}

func routesCompareHandler(c *gin.Context) {
	from := strings.ToUpper(c.DefaultQuery("from", "USA"))
	altsRaw := c.DefaultQuery("alts", "CHN,ARE,SAU,IND")
	alts := make([]string, 0)
	for _, a := range strings.Split(altsRaw, ",") {
		a = strings.TrimSpace(strings.ToUpper(a))
		if a != "" && a != from {
			alts = append(alts, a)
		}
	}
	year, err := strconv.Atoi(c.DefaultQuery("year", "2024"))
	if err != nil {
		c.JSON(400, gin.H{"error": "invalid year"})
		return
	}
	chapter := c.Query("ncm_chapter")
	if len(chapter) == 1 {
		chapter = "0" + chapter
	}
	if chapter == "" || len(chapter) < 2 {
		c.JSON(400, gin.H{"error": "ncm_chapter (2 dÃ­gitos) Ã© obrigatÃ³rio"})
		return
	}

	// TAM base para ano/capÃ­tulo
	var tam float64
	q := `SELECT tam_total_usd FROM v_tam_by_year_chapter WHERE ano=$1 AND ncm_chapter=$2`
	if err := db.QueryRow(q, year, chapter).Scan(&tam); err != nil {
		if err == sql.ErrNoRows {
			c.JSON(404, gin.H{"error": "sem dados para ano/capÃ­tulo", "year": year, "ncm_chapter": chapter})
			return
		}
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	partners := append([]string{from}, alts...)
	weights := map[string]float64{}

	// Pesos: capÃ­tulo â†’ default â†’ fallback 40/60
	if pweights != nil {
		if w, ok := pweights[chapter]; ok {
			for k, v := range w {
				weights[strings.ToUpper(k)] = v
			}
		}
		if len(weights) == 0 {
			if w, ok := pweights["default"]; ok {
				for k, v := range w {
					weights[strings.ToUpper(k)] = v
				}
			}
		}
	}
	if len(weights) == 0 {
		weights[from] = 0.40
		if len(alts) > 0 {
			rem := 0.60 / float64(len(alts))
			for _, a := range alts {
				weights[a] = rem
			}
		}
	}
	// normaliza ao conjunto solicitado
	sum := 0.0
	for _, p := range partners {
		sum += weights[p]
	}
	if sum == 0 {
		eq := 1.0 / float64(len(partners))
		for _, p := range partners {
			weights[p] = eq
		}
		sum = 1.0
	}
	for k, v := range weights {
		weights[k] = v / sum
	}

	// Tarifas (cenÃ¡rios)
	scenarioName := c.DefaultQuery("tariff_scenario", "base")
	scn, hasScenario := tariffs.Scenarios[scenarioName]
	tariffApplied := false

	type Item struct {
		Partner      string  `json:"partner"`
		Share        float64 `json:"share"`
		Factor       float64 `json:"factor"`
		EstimatedUSD float64 `json:"estimated_usd"`
	}

	out := make([]Item, 0, len(partners))
	adjustedTotal := 0.0
	for _, p := range partners {
		share := weights[p]
		est := share * tam

		factor := 1.0
		if hasScenario {
			factor = factorFor(scn, year, chapter, p)
			if factor != 1.0 {
				tariffApplied = true
			}
		}
		est = est * factor
		adjustedTotal += est

		out = append(out, Item{
			Partner:      p,
			Share:        share,
			Factor:       factor,
			EstimatedUSD: est,
		})
	}

	c.JSON(200, gin.H{
		"year":               year,
		"ncm_chapter":        chapter,
		"basis":              "TAM (mview)",
		"tam_total_usd":      tam,
		"from":               from,
		"alts":               alts,
		"tariff_scenario":    scenarioName,
		"tariff_applied":     tariffApplied,
		"adjusted_total_usd": adjustedTotal,
		"note":               "stub com pesos + fatores de tarifa; substituir por dados reais por parceiro em prÃ³xima onda",
		"results":            out,
	})
}

--------------------------------------------------------------------------------
CONTEÚDO DE api\cmd\api\main.go (para comparação)
--------------------------------------------------------------------------------
package main

import (
	"log"

	"bgc-app/internal/app"
	"bgc-app/internal/config"
	"bgc-app/internal/repository/postgres"
)

func main() {
	cfg := config.LoadConfig()

	db := postgres.MustConnect(cfg)
	defer db.Close()

	server := app.NewServer(cfg, db)

	if err := server.Run(); err != nil {
		log.Fatal(err)
	}
}

--------------------------------------------------------------------------------
ANÁLISE DE COMPARAÇÃO
--------------------------------------------------------------------------------
 RESULTADO: Arquivos DIFERENTES
  api\main.go: 16635 bytes
  api\cmd\api\main.go: 337 bytes

DIFERENÇAS ENCONTRADAS:
  Linha 4:
    api\main.go       : 	"fmt"
    api\cmd\api\main.go: 	"log"
  Linha 5:
    api\main.go       : 	"crypto/rand"
    api\cmd\api\main.go: 
  Linha 6:
    api\main.go       : 	"database/sql"
    api\cmd\api\main.go: 	"bgc-app/internal/app"
  Linha 7:
    api\main.go       : 	"encoding/hex"
    api\cmd\api\main.go: 	"bgc-app/internal/config"
  Linha 8:
    api\main.go       : 	"log"
    api\cmd\api\main.go: 	"bgc-app/internal/repository/postgres"
  Linha 9:
    api\main.go       : 	"net/http"
    api\cmd\api\main.go: )
  Linha 10:
    api\main.go       : 	"os"
    api\cmd\api\main.go: 
  Linha 11:
    api\main.go       : 	"strconv"
    api\cmd\api\main.go: func main() {
  Linha 12:
    api\main.go       : 	"strings"  // remova se nÃ£o estiver usando
    api\cmd\api\main.go: 	cfg := config.LoadConfig()
  Linha 13:
    api\main.go       : 	"sync"
    api\cmd\api\main.go: 
  Linha 14:
    api\main.go       : 	"time"
    api\cmd\api\main.go: 	db := postgres.MustConnect(cfg)
  Linha 15:
    api\main.go       : 
    api\cmd\api\main.go: 	defer db.Close()
  Linha 16:
    api\main.go       : 	"github.com/gin-gonic/gin"
    api\cmd\api\main.go: 
  Linha 17:
    api\main.go       : 	_ "github.com/lib/pq"   // <- blank import com ESPAÃ‡O
    api\cmd\api\main.go: 	server := app.NewServer(cfg, db)
  Linha 18:
    api\main.go       : 	"gopkg.in/yaml.v3"
    api\cmd\api\main.go: 
  Linha 19:
    api\main.go       : )
    api\cmd\api\main.go: 	if err := server.Run(); err != nil {
  Linha 20:
    api\main.go       : 
    api\cmd\api\main.go: 		log.Fatal(err)
  Linha 21:
    api\main.go       : /* ===== Tipos de domÃ­nio ===== */
    api\cmd\api\main.go: 	}
  Linha 22:
    api\main.go       : 
    api\cmd\api\main.go: }
  Linha 23:
    api\main.go       : type MarketItem struct {
    api\cmd\api\main.go: 
  Linha 24:
    api\main.go       : 	Ano        int     `json:"ano"`
    api\cmd\api\main.go: 
  Linha 25:
    api\main.go       : 	NCMChapter string  `json:"ncm_chapter"`
    api\cmd\api\main.go: 
  Linha 26:
    api\main.go       : 	ValorUSD   float64 `json:"valor_usd"`
    api\cmd\api\main.go: 
  Linha 27:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 28:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 29:
    api\main.go       : type AppConfig struct {
    api\cmd\api\main.go: 
  Linha 30:
    api\main.go       : 	ScopeChapters []string
    api\cmd\api\main.go: 
  Linha 31:
    api\main.go       : 	SOMBase       float64
    api\cmd\api\main.go: 
  Linha 32:
    api\main.go       : 	SOMAggressive float64
    api\cmd\api\main.go: 
  Linha 33:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 34:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 35:
    api\main.go       : type PartnerWeights map[string]map[string]float64 // chapter -> (partner->share)
    api\cmd\api\main.go: 
  Linha 36:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 37:
    api\main.go       : /* Tarifas (cenÃ¡rios) */
    api\cmd\api\main.go: 
  Linha 38:
    api\main.go       : type TariffScenario struct {
    api\cmd\api\main.go: 
  Linha 39:
    api\main.go       : 	Default  map[string]float64            `yaml:"default"`
    api\cmd\api\main.go: 
  Linha 40:
    api\main.go       : 	Chapters map[string]map[string]float64 `yaml:"chapters"`
    api\cmd\api\main.go: 
  Linha 41:
    api\main.go       : 	Years    map[string]struct {
    api\cmd\api\main.go: 
  Linha 42:
    api\main.go       : 		Default  map[string]float64            `yaml:"default"`
    api\cmd\api\main.go: 
  Linha 43:
    api\main.go       : 		Chapters map[string]map[string]float64 `yaml:"chapters"`
    api\cmd\api\main.go: 
  Linha 44:
    api\main.go       : 	} `yaml:"years"`
    api\cmd\api\main.go: 
  Linha 45:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 46:
    api\main.go       : type TariffScenarios struct {
    api\cmd\api\main.go: 
  Linha 47:
    api\main.go       : 	Scenarios map[string]TariffScenario `yaml:"scenarios"`
    api\cmd\api\main.go: 
  Linha 48:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 49:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 50:
    api\main.go       : /* ===== Estado global ===== */
    api\cmd\api\main.go: 
  Linha 51:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 52:
    api\main.go       : var (
    api\cmd\api\main.go: 
  Linha 53:
    api\main.go       : 	db       *sql.DB
    api\cmd\api\main.go: 
  Linha 54:
    api\main.go       : 	appCfg   AppConfig
    api\cmd\api\main.go: 
  Linha 55:
    api\main.go       : 	pweights PartnerWeights
    api\cmd\api\main.go: 
  Linha 56:
    api\main.go       : 	tariffs  TariffScenarios
    api\cmd\api\main.go: 
  Linha 57:
    api\main.go       : )
    api\cmd\api\main.go: 
  Linha 58:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 59:
    api\main.go       : /* ===== Utilidades ===== */
    api\cmd\api\main.go: 
  Linha 60:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 61:
    api\main.go       : func getenv(key, def string) string {
    api\cmd\api\main.go: 
  Linha 62:
    api\main.go       : 	if v := os.Getenv(key); v != "" {
    api\cmd\api\main.go: 
  Linha 63:
    api\main.go       : 		return v
    api\cmd\api\main.go: 
  Linha 64:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 65:
    api\main.go       : 	return def
    api\cmd\api\main.go: 
  Linha 66:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 67:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 68:
    api\main.go       : func mustConnectDB() *sql.DB {
    api\cmd\api\main.go: 
  Linha 69:
    api\main.go       : 	host := getenv("DB_HOST", "db")
    api\cmd\api\main.go: 
  Linha 70:
    api\main.go       : 	port := getenv("DB_PORT", "5432")
    api\cmd\api\main.go: 
  Linha 71:
    api\main.go       : 	user := getenv("DB_USER", "bgc")
    api\cmd\api\main.go: 
  Linha 72:
    api\main.go       : 	pass := getenv("DB_PASS", "bgc")
    api\cmd\api\main.go: 
  Linha 73:
    api\main.go       : 	name := getenv("DB_NAME", "bgc")
    api\cmd\api\main.go: 
  Linha 74:
    api\main.go       : 	dsn := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable", host, port, user, pass, name)
    api\cmd\api\main.go: 
  Linha 75:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 76:
    api\main.go       : 	var conn *sql.DB
    api\cmd\api\main.go: 
  Linha 77:
    api\main.go       : 	var err error
    api\cmd\api\main.go: 
  Linha 78:
    api\main.go       : 	for i := 0; i < 30; i++ {
    api\cmd\api\main.go: 
  Linha 79:
    api\main.go       : 		conn, err = sql.Open("postgres", dsn)
    api\cmd\api\main.go: 
  Linha 80:
    api\main.go       : 		if err == nil {
    api\cmd\api\main.go: 
  Linha 81:
    api\main.go       : 			if pingErr := conn.Ping(); pingErr == nil {
    api\cmd\api\main.go: 
  Linha 82:
    api\main.go       : 				log.Printf("Connected to Postgres at %s:%s", host, port)
    api\cmd\api\main.go: 
  Linha 83:
    api\main.go       : 				return conn
    api\cmd\api\main.go: 
  Linha 84:
    api\main.go       : 			} else {
    api\cmd\api\main.go: 
  Linha 85:
    api\main.go       : 				err = pingErr
    api\cmd\api\main.go: 
  Linha 86:
    api\main.go       : 			}
    api\cmd\api\main.go: 
  Linha 87:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 88:
    api\main.go       : 		log.Printf("Waiting for Postgres... (%d/30): %v", i+1, err)
    api\cmd\api\main.go: 
  Linha 89:
    api\main.go       : 		time.Sleep(2 * time.Second)
    api\cmd\api\main.go: 
  Linha 90:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 91:
    api\main.go       : 	log.Fatalf("Failed to connect to DB: %v", err)
    api\cmd\api\main.go: 
  Linha 92:
    api\main.go       : 	return nil
    api\cmd\api\main.go: 
  Linha 93:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 94:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 95:
    api\main.go       : func loadConfig() AppConfig {
    api\cmd\api\main.go: 
  Linha 96:
    api\main.go       : 	cfg := AppConfig{
    api\cmd\api\main.go: 
  Linha 97:
    api\main.go       : 		ScopeChapters: []string{"02", "08", "84", "85"},
    api\cmd\api\main.go: 
  Linha 98:
    api\main.go       : 		SOMBase:       0.015,
    api\cmd\api\main.go: 
  Linha 99:
    api\main.go       : 		SOMAggressive: 0.03,
    api\cmd\api\main.go: 
  Linha 100:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 101:
    api\main.go       : 	if v := getenv("SCOPE_CHAPTERS", ""); v != "" {
    api\cmd\api\main.go: 
  Linha 102:
    api\main.go       : 		parts := strings.Split(v, ",")
    api\cmd\api\main.go: 
  Linha 103:
    api\main.go       : 		clean := make([]string, 0, len(parts))
    api\cmd\api\main.go: 
  Linha 104:
    api\main.go       : 		for _, p := range parts {
    api\cmd\api\main.go: 
  Linha 105:
    api\main.go       : 			p = strings.TrimSpace(p)
    api\cmd\api\main.go: 
  Linha 106:
    api\main.go       : 			if len(p) == 1 {
    api\cmd\api\main.go: 
  Linha 107:
    api\main.go       : 				p = "0" + p
    api\cmd\api\main.go: 
  Linha 108:
    api\main.go       : 			}
    api\cmd\api\main.go: 
  Linha 109:
    api\main.go       : 			if len(p) >= 2 {
    api\cmd\api\main.go: 
  Linha 110:
    api\main.go       : 				clean = append(clean, p[:2])
    api\cmd\api\main.go: 
  Linha 111:
    api\main.go       : 			}
    api\cmd\api\main.go: 
  Linha 112:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 113:
    api\main.go       : 		if len(clean) > 0 {
    api\cmd\api\main.go: 
  Linha 114:
    api\main.go       : 			cfg.ScopeChapters = clean
    api\cmd\api\main.go: 
  Linha 115:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 116:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 117:
    api\main.go       : 	if v := getenv("SOM_BASE", ""); v != "" {
    api\cmd\api\main.go: 
  Linha 118:
    api\main.go       : 		if f, err := strconv.ParseFloat(v, 64); err == nil {
    api\cmd\api\main.go: 
  Linha 119:
    api\main.go       : 			cfg.SOMBase = f
    api\cmd\api\main.go: 
  Linha 120:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 121:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 122:
    api\main.go       : 	if v := getenv("SOM_AGGRESSIVE", ""); v != "" {
    api\cmd\api\main.go: 
  Linha 123:
    api\main.go       : 		if f, err := strconv.ParseFloat(v, 64); err == nil {
    api\cmd\api\main.go: 
  Linha 124:
    api\main.go       : 			cfg.SOMAggressive = f
    api\cmd\api\main.go: 
  Linha 125:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 126:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 127:
    api\main.go       : 	return cfg
    api\cmd\api\main.go: 
  Linha 128:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 129:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 130:
    api\main.go       : func loadPartnerWeights() PartnerWeights {
    api\cmd\api\main.go: 
  Linha 131:
    api\main.go       : 	path := getenv("PARTNER_WEIGHTS_FILE", "./config/partners_stub.yaml")
    api\cmd\api\main.go: 
  Linha 132:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 133:
    api\main.go       : 	// Estrutura esperada no YAML: partners: { "<chapter|default>": { "<PAIS>": <peso float> } }
    api\cmd\api\main.go: 
  Linha 134:
    api\main.go       : 	var doc struct {
    api\cmd\api\main.go: 
  Linha 135:
    api\main.go       : 		Partners map[string]map[string]float64 `yaml:"partners"`
    api\cmd\api\main.go: 
  Linha 136:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 137:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 138:
    api\main.go       : 	b, err := os.ReadFile(path)
    api\cmd\api\main.go: 
  Linha 139:
    api\main.go       : 	if err != nil {
    api\cmd\api\main.go: 
  Linha 140:
    api\main.go       : 		log.Printf("partner weights not found (%s): using defaults", path)
    api\cmd\api\main.go: 
  Linha 141:
    api\main.go       : 		return nil
    api\cmd\api\main.go: 
  Linha 142:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 143:
    api\main.go       : 	if err := yaml.Unmarshal(b, &doc); err != nil {
    api\cmd\api\main.go: 
  Linha 144:
    api\main.go       : 		log.Printf("failed to parse partner weights: %v", err)
    api\cmd\api\main.go: 
  Linha 145:
    api\main.go       : 		return nil
    api\cmd\api\main.go: 
  Linha 146:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 147:
    api\main.go       : 	if len(doc.Partners) == 0 {
    api\cmd\api\main.go: 
  Linha 148:
    api\main.go       : 		log.Printf("partner weights file is empty: %s", path)
    api\cmd\api\main.go: 
  Linha 149:
    api\main.go       : 		return nil
    api\cmd\api\main.go: 
  Linha 150:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 151:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 152:
    api\main.go       : 	out := make(PartnerWeights) // PartnerWeights == map[string]map[string]float64
    api\cmd\api\main.go: 
  Linha 153:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 154:
    api\main.go       : 	for chapterKey, partnersMap := range doc.Partners {
    api\cmd\api\main.go: 
  Linha 155:
    api\main.go       : 		// normaliza chave do capÃ­tulo (mantÃ©m "default" como estÃ¡; capitulos "84" etc. sem mexer)
    api\cmd\api\main.go: 
  Linha 156:
    api\main.go       : 		chKey := strings.TrimSpace(chapterKey)
    api\cmd\api\main.go: 
  Linha 157:
    api\main.go       : 		if chKey != "default" && len(chKey) == 1 {
    api\cmd\api\main.go: 
  Linha 158:
    api\main.go       : 			chKey = "0" + chKey
    api\cmd\api\main.go: 
  Linha 159:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 160:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 161:
    api\main.go       : 		// Cria o mapa interno para este capÃ­tulo caso ainda nÃ£o exista
    api\cmd\api\main.go: 
  Linha 162:
    api\main.go       : 		if _, ok := out[chKey]; !ok {
    api\cmd\api\main.go: 
  Linha 163:
    api\main.go       : 			out[chKey] = make(map[string]float64)
    api\cmd\api\main.go: 
  Linha 164:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 165:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 166:
    api\main.go       : 		for partnerCode, weight := range partnersMap {
    api\cmd\api\main.go: 
  Linha 167:
    api\main.go       : 			p := strings.ToUpper(strings.TrimSpace(partnerCode))
    api\cmd\api\main.go: 
  Linha 168:
    api\main.go       : 			out[chKey][p] = weight // <- aqui o tipo Ã© float64, coerente com map[string]float64
    api\cmd\api\main.go: 
  Linha 169:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 170:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 171:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 172:
    api\main.go       : 	return out
    api\cmd\api\main.go: 
  Linha 173:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 174:
    api\main.go       : func loadTariffs() {
    api\cmd\api\main.go: 
  Linha 175:
    api\main.go       : 	path := getenv("TARIFF_SCENARIOS_FILE", "./config/tariff_scenarios.yaml")
    api\cmd\api\main.go: 
  Linha 176:
    api\main.go       : 	b, err := os.ReadFile(path)
    api\cmd\api\main.go: 
  Linha 177:
    api\main.go       : 	if err != nil {
    api\cmd\api\main.go: 
  Linha 178:
    api\main.go       : 		log.Printf("tariff scenarios not found (%s): continuing without tariffs", path)
    api\cmd\api\main.go: 
  Linha 179:
    api\main.go       : 		return
    api\cmd\api\main.go: 
  Linha 180:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 181:
    api\main.go       : 	if err := yaml.Unmarshal(b, &tariffs); err != nil {
    api\cmd\api\main.go: 
  Linha 182:
    api\main.go       : 		log.Printf("failed to parse tariff scenarios: %v", err)
    api\cmd\api\main.go: 
  Linha 183:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 184:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 185:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 186:
    api\main.go       : /* Resolve fator de tarifa (prioridade: ano.capÃ­tulo â†’ ano.default â†’ capÃ­tulo â†’ default â†’ 1.0) */
    api\cmd\api\main.go: 
  Linha 187:
    api\main.go       : func factorFor(scn TariffScenario, year int, chapter, partner string) float64 {
    api\cmd\api\main.go: 
  Linha 188:
    api\main.go       : 	p := strings.ToUpper(partner)
    api\cmd\api\main.go: 
  Linha 189:
    api\main.go       : 	chap := chapter
    api\cmd\api\main.go: 
  Linha 190:
    api\main.go       : 	ys := fmt.Sprintf("%d", year)
    api\cmd\api\main.go: 
  Linha 191:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 192:
    api\main.go       : 	if y, ok := scn.Years[ys]; ok {
    api\cmd\api\main.go: 
  Linha 193:
    api\main.go       : 		if mp, ok := y.Chapters[chap]; ok {
    api\cmd\api\main.go: 
  Linha 194:
    api\main.go       : 			if f, ok := mp[p]; ok {
    api\cmd\api\main.go: 
  Linha 195:
    api\main.go       : 				return f
    api\cmd\api\main.go: 
  Linha 196:
    api\main.go       : 			}
    api\cmd\api\main.go: 
  Linha 197:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 198:
    api\main.go       : 		if f, ok := y.Default[p]; ok {
    api\cmd\api\main.go: 
  Linha 199:
    api\main.go       : 			return f
    api\cmd\api\main.go: 
  Linha 200:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 201:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 202:
    api\main.go       : 	if mp, ok := scn.Chapters[chap]; ok {
    api\cmd\api\main.go: 
  Linha 203:
    api\main.go       : 		if f, ok := mp[p]; ok {
    api\cmd\api\main.go: 
  Linha 204:
    api\main.go       : 			return f
    api\cmd\api\main.go: 
  Linha 205:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 206:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 207:
    api\main.go       : 	if f, ok := scn.Default[p]; ok {
    api\cmd\api\main.go: 
  Linha 208:
    api\main.go       : 		return f
    api\cmd\api\main.go: 
  Linha 209:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 210:
    api\main.go       : 	return 1.0
    api\cmd\api\main.go: 
  Linha 211:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 212:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 213:
    api\main.go       : /* ===== Handlers ===== */
    api\cmd\api\main.go: 
  Linha 214:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 215:
    api\main.go       : func corsMiddleware() gin.HandlerFunc {
    api\cmd\api\main.go: 
  Linha 216:
    api\main.go       : 	return func(c *gin.Context) {
    api\cmd\api\main.go: 
  Linha 217:
    api\main.go       : 		origin := c.GetHeader("Origin")
    api\cmd\api\main.go: 
  Linha 218:
    api\main.go       : 		if origin == "" {
    api\cmd\api\main.go: 
  Linha 219:
    api\main.go       : 			origin = "*" // quando a origem Ã© vazia (ex.: curl), tudo bem
    api\cmd\api\main.go: 
  Linha 220:
    api\main.go       : 		} else {
    api\cmd\api\main.go: 
  Linha 221:
    api\main.go       : 			// Em dev, pode liberar geral. Se preferir restringir:
    api\cmd\api\main.go: 
  Linha 222:
    api\main.go       : 			// if origin == "http://localhost:3000" { ... }
    api\cmd\api\main.go: 
  Linha 223:
    api\main.go       : 			origin = "*"
    api\cmd\api\main.go: 
  Linha 224:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 225:
    api\main.go       : 		c.Header("Access-Control-Allow-Origin", origin)
    api\cmd\api\main.go: 
  Linha 226:
    api\main.go       : 		c.Header("Vary", "Origin")
    api\cmd\api\main.go: 
  Linha 227:
    api\main.go       : 		c.Header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
    api\cmd\api\main.go: 
  Linha 228:
    api\main.go       : 		c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")
    api\cmd\api\main.go: 
  Linha 229:
    api\main.go       : 		// NÃ£o vamos usar cookies -> Credenciais desabilitadas
    api\cmd\api\main.go: 
  Linha 230:
    api\main.go       : 		// c.Header("Access-Control-Allow-Credentials", "true")
    api\cmd\api\main.go: 
  Linha 231:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 232:
    api\main.go       : 		if c.Request.Method == http.MethodOptions {
    api\cmd\api\main.go: 
  Linha 233:
    api\main.go       : 			c.AbortWithStatus(204)
    api\cmd\api\main.go: 
  Linha 234:
    api\main.go       : 			return
    api\cmd\api\main.go: 
  Linha 235:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 236:
    api\main.go       : 		c.Next()
    api\cmd\api\main.go: 
  Linha 237:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 238:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 239:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 240:
    api\main.go       : // ===== S2-16: Request ID, Logs JSON e MÃ©tricas =====
    api\cmd\api\main.go: 
  Linha 241:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 242:
    api\main.go       : type routeMetrics struct {
    api\cmd\api\main.go: 
  Linha 243:
    api\main.go       : 	Requests     int64   `json:"requests"`
    api\cmd\api\main.go: 
  Linha 244:
    api\main.go       : 	Status2xx    int64   `json:"status_2xx"`
    api\cmd\api\main.go: 
  Linha 245:
    api\main.go       : 	Status4xx    int64   `json:"status_4xx"`
    api\cmd\api\main.go: 
  Linha 246:
    api\main.go       : 	Status5xx    int64   `json:"status_5xx"`
    api\cmd\api\main.go: 
  Linha 247:
    api\main.go       : 	SumLatencyMs int64   `json:"sum_latency_ms"`
    api\cmd\api\main.go: 
  Linha 248:
    api\main.go       : 	AvgLatencyMs float64 `json:"avg_latency_ms"`
    api\cmd\api\main.go: 
  Linha 249:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 250:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 251:
    api\main.go       : var (
    api\cmd\api\main.go: 
  Linha 252:
    api\main.go       : 	metricsStart   = time.Now()
    api\cmd\api\main.go: 
  Linha 253:
    api\main.go       : 	metricsMu      sync.RWMutex
    api\cmd\api\main.go: 
  Linha 254:
    api\main.go       : 	totalRequests  int64
    api\cmd\api\main.go: 
  Linha 255:
    api\main.go       : 	statusCounters = map[int]int64{}              // ex.: 200->123, 404->7...
    api\cmd\api\main.go: 
  Linha 256:
    api\main.go       : 	byRoute        = map[string]*routeMetrics{}   // chave: "METHOD " + rota (FullPath)
    api\cmd\api\main.go: 
  Linha 257:
    api\main.go       : )
    api\cmd\api\main.go: 
  Linha 258:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 259:
    api\main.go       : func newReqID() string {
    api\cmd\api\main.go: 
  Linha 260:
    api\main.go       : 	b := make([]byte, 12)
    api\cmd\api\main.go: 
  Linha 261:
    api\main.go       : 	if _, err := rand.Read(b); err != nil {
    api\cmd\api\main.go: 
  Linha 262:
    api\main.go       : 		return strconv.FormatInt(time.Now().UnixNano(), 10)
    api\cmd\api\main.go: 
  Linha 263:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 264:
    api\main.go       : 	return hex.EncodeToString(b)
    api\cmd\api\main.go: 
  Linha 265:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 266:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 267:
    api\main.go       : // X-Request-Id: usa o header do cliente se vier, senÃ£o gera um novo
    api\cmd\api\main.go: 
  Linha 268:
    api\main.go       : func requestIDMiddleware() gin.HandlerFunc {
    api\cmd\api\main.go: 
  Linha 269:
    api\main.go       : 	return func(c *gin.Context) {
    api\cmd\api\main.go: 
  Linha 270:
    api\main.go       : 		rid := c.Request.Header.Get("X-Request-Id")
    api\cmd\api\main.go: 
  Linha 271:
    api\main.go       : 		if rid == "" {
    api\cmd\api\main.go: 
  Linha 272:
    api\main.go       : 			rid = newReqID()
    api\cmd\api\main.go: 
  Linha 273:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 274:
    api\main.go       : 		c.Set("req_id", rid)
    api\cmd\api\main.go: 
  Linha 275:
    api\main.go       : 		c.Writer.Header().Set("X-Request-Id", rid)
    api\cmd\api\main.go: 
  Linha 276:
    api\main.go       : 		c.Next()
    api\cmd\api\main.go: 
  Linha 277:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 278:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 279:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 280:
    api\main.go       : // MÃ©tricas + log estruturado (JSON)
    api\cmd\api\main.go: 
  Linha 281:
    api\main.go       : func metricsAndLogMiddleware() gin.HandlerFunc {
    api\cmd\api\main.go: 
  Linha 282:
    api\main.go       : 	return func(c *gin.Context) {
    api\cmd\api\main.go: 
  Linha 283:
    api\main.go       : 		start := time.Now()
    api\cmd\api\main.go: 
  Linha 284:
    api\main.go       : 		c.Next()
    api\cmd\api\main.go: 
  Linha 285:
    api\main.go       : 		latMs := time.Since(start).Milliseconds()
    api\cmd\api\main.go: 
  Linha 286:
    api\main.go       : 		status := c.Writer.Status()
    api\cmd\api\main.go: 
  Linha 287:
    api\main.go       : 		method := c.Request.Method
    api\cmd\api\main.go: 
  Linha 288:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 289:
    api\main.go       : 		route := c.FullPath()
    api\cmd\api\main.go: 
  Linha 290:
    api\main.go       : 		if route == "" {
    api\cmd\api\main.go: 
  Linha 291:
    api\main.go       : 			route = c.Request.URL.Path
    api\cmd\api\main.go: 
  Linha 292:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 293:
    api\main.go       : 		key := method + " " + route
    api\cmd\api\main.go: 
  Linha 294:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 295:
    api\main.go       : 		metricsMu.Lock()
    api\cmd\api\main.go: 
  Linha 296:
    api\main.go       : 		totalRequests++
    api\cmd\api\main.go: 
  Linha 297:
    api\main.go       : 		statusCounters[status]++
    api\cmd\api\main.go: 
  Linha 298:
    api\main.go       : 		rm := byRoute[key]
    api\cmd\api\main.go: 
  Linha 299:
    api\main.go       : 		if rm == nil {
    api\cmd\api\main.go: 
  Linha 300:
    api\main.go       : 			rm = &routeMetrics{}
    api\cmd\api\main.go: 
  Linha 301:
    api\main.go       : 			byRoute[key] = rm
    api\cmd\api\main.go: 
  Linha 302:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 303:
    api\main.go       : 		rm.Requests++
    api\cmd\api\main.go: 
  Linha 304:
    api\main.go       : 		rm.SumLatencyMs += latMs
    api\cmd\api\main.go: 
  Linha 305:
    api\main.go       : 		switch {
    api\cmd\api\main.go: 
  Linha 306:
    api\main.go       : 		case status >= 200 && status < 300:
    api\cmd\api\main.go: 
  Linha 307:
    api\main.go       : 			rm.Status2xx++
    api\cmd\api\main.go: 
  Linha 308:
    api\main.go       : 		case status >= 400 && status < 500:
    api\cmd\api\main.go: 
  Linha 309:
    api\main.go       : 			rm.Status4xx++
    api\cmd\api\main.go: 
  Linha 310:
    api\main.go       : 		case status >= 500:
    api\cmd\api\main.go: 
  Linha 311:
    api\main.go       : 			rm.Status5xx++
    api\cmd\api\main.go: 
  Linha 312:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 313:
    api\main.go       : 		if rm.Requests > 0 {
    api\cmd\api\main.go: 
  Linha 314:
    api\main.go       : 			rm.AvgLatencyMs = float64(rm.SumLatencyMs) / float64(rm.Requests)
    api\cmd\api\main.go: 
  Linha 315:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 316:
    api\main.go       : 		metricsMu.Unlock()
    api\cmd\api\main.go: 
  Linha 317:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 318:
    api\main.go       : 		// Log JSON minimalista
    api\cmd\api\main.go: 
  Linha 319:
    api\main.go       : 		rid, _ := c.Get("req_id")
    api\cmd\api\main.go: 
  Linha 320:
    api\main.go       : 		log.Printf(`{"ts":"%s","level":"info","req_id":"%v","method":"%s","path":"%s","route":"%s","status":%d,"latency_ms":%d,"ip":"%s","ua":"%s"}`,
    api\cmd\api\main.go: 
  Linha 321:
    api\main.go       : 			time.Now().Format(time.RFC3339Nano),
    api\cmd\api\main.go: 
  Linha 322:
    api\main.go       : 			rid, method, c.Request.URL.Path, route, status, latMs, c.ClientIP(), c.Request.UserAgent(),
    api\cmd\api\main.go: 
  Linha 323:
    api\main.go       : 		)
    api\cmd\api\main.go: 
  Linha 324:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 325:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 326:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 327:
    api\main.go       : // Handler do /metrics (snapshot em JSON)
    api\cmd\api\main.go: 
  Linha 328:
    api\main.go       : func metricsHandler(c *gin.Context) {
    api\cmd\api\main.go: 
  Linha 329:
    api\main.go       : 	metricsMu.RLock()
    api\cmd\api\main.go: 
  Linha 330:
    api\main.go       : 	defer metricsMu.RUnlock()
    api\cmd\api\main.go: 
  Linha 331:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 332:
    api\main.go       : 	// copia defensiva para resposta
    api\cmd\api\main.go: 
  Linha 333:
    api\main.go       : 	statusByString := map[string]int64{}
    api\cmd\api\main.go: 
  Linha 334:
    api\main.go       : 	for code, cnt := range statusCounters {
    api\cmd\api\main.go: 
  Linha 335:
    api\main.go       : 		statusByString[strconv.Itoa(code)] = cnt
    api\cmd\api\main.go: 
  Linha 336:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 337:
    api\main.go       : 	routesCopy := map[string]routeMetrics{}
    api\cmd\api\main.go: 
  Linha 338:
    api\main.go       : 	for k, v := range byRoute {
    api\cmd\api\main.go: 
  Linha 339:
    api\main.go       : 		routesCopy[k] = *v
    api\cmd\api\main.go: 
  Linha 340:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 341:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 342:
    api\main.go       : 	c.JSON(http.StatusOK, gin.H{
    api\cmd\api\main.go: 
  Linha 343:
    api\main.go       : 		"uptime_seconds": int64(time.Since(metricsStart).Seconds()),
    api\cmd\api\main.go: 
  Linha 344:
    api\main.go       : 		"requests_total": totalRequests,
    api\cmd\api\main.go: 
  Linha 345:
    api\main.go       : 		"requests_by_status": statusByString,
    api\cmd\api\main.go: 
  Linha 346:
    api\main.go       : 		"routes": routesCopy,
    api\cmd\api\main.go: 
  Linha 347:
    api\main.go       : 	})
    api\cmd\api\main.go: 
  Linha 348:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 349:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 350:
    api\main.go       : func healthHandler(c *gin.Context) {
    api\cmd\api\main.go: 
  Linha 351:
    api\main.go       :     // opcional: checar DB rapidamente (descomente se quiser)
    api\cmd\api\main.go: 
  Linha 352:
    api\main.go       :     // if err := db.Ping(); err != nil {
    api\cmd\api\main.go: 
  Linha 353:
    api\main.go       :     //     c.JSON(500, gin.H{"status":"degraded","error": err.Error()})
    api\cmd\api\main.go: 
  Linha 354:
    api\main.go       :     //     return
    api\cmd\api\main.go: 
  Linha 355:
    api\main.go       :     // }
    api\cmd\api\main.go: 
  Linha 356:
    api\main.go       :     c.JSON(200, gin.H{
    api\cmd\api\main.go: 
  Linha 357:
    api\main.go       :         "select": 1,           // compat com a resposta antiga
    api\cmd\api\main.go: 
  Linha 358:
    api\main.go       :         "status": "ok",
    api\cmd\api\main.go: 
  Linha 359:
    api\main.go       :         "chapters_onda1":   appCfg.ScopeChapters,
    api\cmd\api\main.go: 
  Linha 360:
    api\main.go       :         "partner_weights":  (pweights != nil),
    api\cmd\api\main.go: 
  Linha 361:
    api\main.go       :         "tariffs_loaded":   (len(tariffs.Scenarios) > 0),
    api\cmd\api\main.go: 
  Linha 362:
    api\main.go       :         "available_scenarios": func() []string {
    api\cmd\api\main.go: 
  Linha 363:
    api\main.go       :             keys := make([]string, 0, len(tariffs.Scenarios))
    api\cmd\api\main.go: 
  Linha 364:
    api\main.go       :             for k := range tariffs.Scenarios { keys = append(keys, k) }
    api\cmd\api\main.go: 
  Linha 365:
    api\main.go       :             return keys
    api\cmd\api\main.go: 
  Linha 366:
    api\main.go       :         }(),
    api\cmd\api\main.go: 
  Linha 367:
    api\main.go       :     })
    api\cmd\api\main.go: 
  Linha 368:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 369:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 370:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 371:
    api\main.go       : func main() {
    api\cmd\api\main.go: 
  Linha 372:
    api\main.go       : 	gin.SetMode(gin.ReleaseMode)
    api\cmd\api\main.go: 
  Linha 373:
    api\main.go       : 	appCfg = loadConfig()
    api\cmd\api\main.go: 
  Linha 374:
    api\main.go       : 	pweights = loadPartnerWeights()
    api\cmd\api\main.go: 
  Linha 375:
    api\main.go       : 	loadTariffs()
    api\cmd\api\main.go: 
  Linha 376:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 377:
    api\main.go       : 	db = mustConnectDB()
    api\cmd\api\main.go: 
  Linha 378:
    api\main.go       : 	defer db.Close()
    api\cmd\api\main.go: 
  Linha 379:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 380:
    api\main.go       : 	r := gin.Default()
    api\cmd\api\main.go: 
  Linha 381:
    api\main.go       : 	r.Use(corsMiddleware())
    api\cmd\api\main.go: 
  Linha 382:
    api\main.go       : 	r.Use(requestIDMiddleware())     // S2-16
    api\cmd\api\main.go: 
  Linha 383:
    api\main.go       : 	r.Use(metricsAndLogMiddleware()) // S2-16
    api\cmd\api\main.go: 
  Linha 384:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 385:
    api\main.go       : 	// --- ROTAS (sem duplicaÃ§Ã£o) ---
    api\cmd\api\main.go: 
  Linha 386:
    api\main.go       : 	// Health (uma vez cada; ambos usam o mesmo handler)
    api\cmd\api\main.go: 
  Linha 387:
    api\main.go       : 	r.GET("/health",  healthHandler)
    api\cmd\api\main.go: 
  Linha 388:
    api\main.go       : 	r.GET("/healthz", healthHandler)
    api\cmd\api\main.go: 
  Linha 389:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 390:
    api\main.go       : 	// MÃ©tricas (S2-16)
    api\cmd\api\main.go: 
  Linha 391:
    api\main.go       : 	r.GET("/metrics", metricsHandler)
    api\cmd\api\main.go: 
  Linha 392:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 393:
    api\main.go       : 	// OpenAPI & ReDoc
    api\cmd\api\main.go: 
  Linha 394:
    api\main.go       : 	r.GET("/openapi.yaml", func(c *gin.Context) { c.File("./openapi.yaml") })
    api\cmd\api\main.go: 
  Linha 395:
    api\main.go       : 	r.GET("/docs", func(c *gin.Context) {
    api\cmd\api\main.go: 
  Linha 396:
    api\main.go       : 		html := `<!doctype html><html><head><meta charset="utf-8"><title>BGC API Docs</title></head>
    api\cmd\api\main.go: 
  Linha 397:
    api\main.go       : <body><redoc spec-url='/openapi.yaml'></redoc>
    api\cmd\api\main.go: 
  Linha 398:
    api\main.go       : <script src="https://cdn.redoc.ly/redoc/latest/bundles/redoc.standalone.js"></script></body></html>`
    api\cmd\api\main.go: 
  Linha 399:
    api\main.go       : 		c.Data(200, "text/html; charset=utf-8", []byte(html))
    api\cmd\api\main.go: 
  Linha 400:
    api\main.go       : 	})
    api\cmd\api\main.go: 
  Linha 401:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 402:
    api\main.go       : 	// Endpoints analÃ­ticos
    api\cmd\api\main.go: 
  Linha 403:
    api\main.go       : 	r.GET("/market/size",    marketSizeHandler)
    api\cmd\api\main.go: 
  Linha 404:
    api\main.go       : 	r.GET("/routes/compare", routesCompareHandler)
    api\cmd\api\main.go: 
  Linha 405:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 406:
    api\main.go       : 	port := getenv("PORT", "8080")
    api\cmd\api\main.go: 
  Linha 407:
    api\main.go       : 	log.Printf("BGC API up on :%s", port)
    api\cmd\api\main.go: 
  Linha 408:
    api\main.go       : 	if err := r.Run(":" + port); err != nil {
    api\cmd\api\main.go: 
  Linha 409:
    api\main.go       : 		log.Fatal(err)
    api\cmd\api\main.go: 
  Linha 410:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 411:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 412:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 413:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 414:
    api\main.go       : func marketSizeHandler(c *gin.Context) {
    api\cmd\api\main.go: 
  Linha 415:
    api\main.go       : 	metric := strings.ToUpper(c.Query("metric"))
    api\cmd\api\main.go: 
  Linha 416:
    api\main.go       : 	if metric == "" {
    api\cmd\api\main.go: 
  Linha 417:
    api\main.go       : 		c.JSON(http.StatusBadRequest, gin.H{"error": "metric is required [TAM|SAM|SOM]"})
    api\cmd\api\main.go: 
  Linha 418:
    api\main.go       : 		return
    api\cmd\api\main.go: 
  Linha 419:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 420:
    api\main.go       : 	yearFrom, _ := strconv.Atoi(c.DefaultQuery("year_from", "2020"))
    api\cmd\api\main.go: 
  Linha 421:
    api\main.go       : 	yearTo, _ := strconv.Atoi(c.DefaultQuery("year_to", "2025"))
    api\cmd\api\main.go: 
  Linha 422:
    api\main.go       : 	ncmChapter := c.Query("ncm_chapter")
    api\cmd\api\main.go: 
  Linha 423:
    api\main.go       : 	scenario := strings.ToLower(c.DefaultQuery("scenario", "base"))
    api\cmd\api\main.go: 
  Linha 424:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 425:
    api\main.go       : 	var sb strings.Builder
    api\cmd\api\main.go: 
  Linha 426:
    api\main.go       : 	args := []any{yearFrom, yearTo}
    api\cmd\api\main.go: 
  Linha 427:
    api\main.go       : 	sb.WriteString(`SELECT ano, ncm_chapter, tam_total_usd
    api\cmd\api\main.go: 
  Linha 428:
    api\main.go       : 	                FROM v_tam_by_year_chapter
    api\cmd\api\main.go: 
  Linha 429:
    api\main.go       : 	               WHERE ano BETWEEN $1 AND $2`)
    api\cmd\api\main.go: 
  Linha 430:
    api\main.go       : 	argPos := 3
    api\cmd\api\main.go: 
  Linha 431:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 432:
    api\main.go       : 	if metric == "SAM" || metric == "SOM" {
    api\cmd\api\main.go: 
  Linha 433:
    api\main.go       : 		if len(appCfg.ScopeChapters) == 0 {
    api\cmd\api\main.go: 
  Linha 434:
    api\main.go       : 			c.JSON(500, gin.H{"error": "server misconfigured: scope chapters empty"})
    api\cmd\api\main.go: 
  Linha 435:
    api\main.go       : 			return
    api\cmd\api\main.go: 
  Linha 436:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 437:
    api\main.go       : 		ph := make([]string, 0, len(appCfg.ScopeChapters))
    api\cmd\api\main.go: 
  Linha 438:
    api\main.go       : 		for range appCfg.ScopeChapters {
    api\cmd\api\main.go: 
  Linha 439:
    api\main.go       : 			ph = append(ph, fmt.Sprintf("$%d", argPos))
    api\cmd\api\main.go: 
  Linha 440:
    api\main.go       : 			argPos++
    api\cmd\api\main.go: 
  Linha 441:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 442:
    api\main.go       : 		sb.WriteString(" AND ncm_chapter IN (" + strings.Join(ph, ",") + ")")
    api\cmd\api\main.go: 
  Linha 443:
    api\main.go       : 		for _, ch := range appCfg.ScopeChapters {
    api\cmd\api\main.go: 
  Linha 444:
    api\main.go       : 			args = append(args, ch)
    api\cmd\api\main.go: 
  Linha 445:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 446:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 447:
    api\main.go       : 	if ncmChapter != "" {
    api\cmd\api\main.go: 
  Linha 448:
    api\main.go       : 		sb.WriteString(fmt.Sprintf(" AND ncm_chapter = $%d", argPos))
    api\cmd\api\main.go: 
  Linha 449:
    api\main.go       : 		args = append(args, ncmChapter)
    api\cmd\api\main.go: 
  Linha 450:
    api\main.go       : 		argPos++
    api\cmd\api\main.go: 
  Linha 451:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 452:
    api\main.go       : 	sb.WriteString(" ORDER BY ano, ncm_chapter")
    api\cmd\api\main.go: 
  Linha 453:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 454:
    api\main.go       : 	rows, err := db.Query(sb.String(), args...)
    api\cmd\api\main.go: 
  Linha 455:
    api\main.go       : 	if err != nil {
    api\cmd\api\main.go: 
  Linha 456:
    api\main.go       : 		c.JSON(500, gin.H{"error": err.Error()})
    api\cmd\api\main.go: 
  Linha 457:
    api\main.go       : 		return
    api\cmd\api\main.go: 
  Linha 458:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 459:
    api\main.go       : 	defer rows.Close()
    api\cmd\api\main.go: 
  Linha 460:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 461:
    api\main.go       : 	items := make([]MarketItem, 0, 64)
    api\cmd\api\main.go: 
  Linha 462:
    api\main.go       : 	for rows.Next() {
    api\cmd\api\main.go: 
  Linha 463:
    api\main.go       : 		var mi MarketItem
    api\cmd\api\main.go: 
  Linha 464:
    api\main.go       : 		var tam float64
    api\cmd\api\main.go: 
  Linha 465:
    api\main.go       : 		if err := rows.Scan(&mi.Ano, &mi.NCMChapter, &tam); err != nil {
    api\cmd\api\main.go: 
  Linha 466:
    api\main.go       : 			c.JSON(500, gin.H{"error": err.Error()})
    api\cmd\api\main.go: 
  Linha 467:
    api\main.go       : 			return
    api\cmd\api\main.go: 
  Linha 468:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 469:
    api\main.go       : 		switch metric {
    api\cmd\api\main.go: 
  Linha 470:
    api\main.go       : 		case "TAM", "SAM":
    api\cmd\api\main.go: 
  Linha 471:
    api\main.go       : 			mi.ValorUSD = tam
    api\cmd\api\main.go: 
  Linha 472:
    api\main.go       : 		case "SOM":
    api\cmd\api\main.go: 
  Linha 473:
    api\main.go       : 			switch scenario {
    api\cmd\api\main.go: 
  Linha 474:
    api\main.go       : 			case "aggressive":
    api\cmd\api\main.go: 
  Linha 475:
    api\main.go       : 				mi.ValorUSD = tam * appCfg.SOMAggressive
    api\cmd\api\main.go: 
  Linha 476:
    api\main.go       : 			default:
    api\cmd\api\main.go: 
  Linha 477:
    api\main.go       : 				mi.ValorUSD = tam * appCfg.SOMBase
    api\cmd\api\main.go: 
  Linha 478:
    api\main.go       : 			}
    api\cmd\api\main.go: 
  Linha 479:
    api\main.go       : 		default:
    api\cmd\api\main.go: 
  Linha 480:
    api\main.go       : 			c.JSON(400, gin.H{"error": "invalid metric; use TAM|SAM|SOM"})
    api\cmd\api\main.go: 
  Linha 481:
    api\main.go       : 			return
    api\cmd\api\main.go: 
  Linha 482:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 483:
    api\main.go       : 		items = append(items, mi)
    api\cmd\api\main.go: 
  Linha 484:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 485:
    api\main.go       : 	c.JSON(200, gin.H{"metric": metric, "scenario": scenario, "items": items})
    api\cmd\api\main.go: 
  Linha 486:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 487:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 488:
    api\main.go       : func routesCompareHandler(c *gin.Context) {
    api\cmd\api\main.go: 
  Linha 489:
    api\main.go       : 	from := strings.ToUpper(c.DefaultQuery("from", "USA"))
    api\cmd\api\main.go: 
  Linha 490:
    api\main.go       : 	altsRaw := c.DefaultQuery("alts", "CHN,ARE,SAU,IND")
    api\cmd\api\main.go: 
  Linha 491:
    api\main.go       : 	alts := make([]string, 0)
    api\cmd\api\main.go: 
  Linha 492:
    api\main.go       : 	for _, a := range strings.Split(altsRaw, ",") {
    api\cmd\api\main.go: 
  Linha 493:
    api\main.go       : 		a = strings.TrimSpace(strings.ToUpper(a))
    api\cmd\api\main.go: 
  Linha 494:
    api\main.go       : 		if a != "" && a != from {
    api\cmd\api\main.go: 
  Linha 495:
    api\main.go       : 			alts = append(alts, a)
    api\cmd\api\main.go: 
  Linha 496:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 497:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 498:
    api\main.go       : 	year, err := strconv.Atoi(c.DefaultQuery("year", "2024"))
    api\cmd\api\main.go: 
  Linha 499:
    api\main.go       : 	if err != nil {
    api\cmd\api\main.go: 
  Linha 500:
    api\main.go       : 		c.JSON(400, gin.H{"error": "invalid year"})
    api\cmd\api\main.go: 
  Linha 501:
    api\main.go       : 		return
    api\cmd\api\main.go: 
  Linha 502:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 503:
    api\main.go       : 	chapter := c.Query("ncm_chapter")
    api\cmd\api\main.go: 
  Linha 504:
    api\main.go       : 	if len(chapter) == 1 {
    api\cmd\api\main.go: 
  Linha 505:
    api\main.go       : 		chapter = "0" + chapter
    api\cmd\api\main.go: 
  Linha 506:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 507:
    api\main.go       : 	if chapter == "" || len(chapter) < 2 {
    api\cmd\api\main.go: 
  Linha 508:
    api\main.go       : 		c.JSON(400, gin.H{"error": "ncm_chapter (2 dÃ­gitos) Ã© obrigatÃ³rio"})
    api\cmd\api\main.go: 
  Linha 509:
    api\main.go       : 		return
    api\cmd\api\main.go: 
  Linha 510:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 511:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 512:
    api\main.go       : 	// TAM base para ano/capÃ­tulo
    api\cmd\api\main.go: 
  Linha 513:
    api\main.go       : 	var tam float64
    api\cmd\api\main.go: 
  Linha 514:
    api\main.go       : 	q := `SELECT tam_total_usd FROM v_tam_by_year_chapter WHERE ano=$1 AND ncm_chapter=$2`
    api\cmd\api\main.go: 
  Linha 515:
    api\main.go       : 	if err := db.QueryRow(q, year, chapter).Scan(&tam); err != nil {
    api\cmd\api\main.go: 
  Linha 516:
    api\main.go       : 		if err == sql.ErrNoRows {
    api\cmd\api\main.go: 
  Linha 517:
    api\main.go       : 			c.JSON(404, gin.H{"error": "sem dados para ano/capÃ­tulo", "year": year, "ncm_chapter": chapter})
    api\cmd\api\main.go: 
  Linha 518:
    api\main.go       : 			return
    api\cmd\api\main.go: 
  Linha 519:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 520:
    api\main.go       : 		c.JSON(500, gin.H{"error": err.Error()})
    api\cmd\api\main.go: 
  Linha 521:
    api\main.go       : 		return
    api\cmd\api\main.go: 
  Linha 522:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 523:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 524:
    api\main.go       : 	partners := append([]string{from}, alts...)
    api\cmd\api\main.go: 
  Linha 525:
    api\main.go       : 	weights := map[string]float64{}
    api\cmd\api\main.go: 
  Linha 526:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 527:
    api\main.go       : 	// Pesos: capÃ­tulo â†’ default â†’ fallback 40/60
    api\cmd\api\main.go: 
  Linha 528:
    api\main.go       : 	if pweights != nil {
    api\cmd\api\main.go: 
  Linha 529:
    api\main.go       : 		if w, ok := pweights[chapter]; ok {
    api\cmd\api\main.go: 
  Linha 530:
    api\main.go       : 			for k, v := range w {
    api\cmd\api\main.go: 
  Linha 531:
    api\main.go       : 				weights[strings.ToUpper(k)] = v
    api\cmd\api\main.go: 
  Linha 532:
    api\main.go       : 			}
    api\cmd\api\main.go: 
  Linha 533:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 534:
    api\main.go       : 		if len(weights) == 0 {
    api\cmd\api\main.go: 
  Linha 535:
    api\main.go       : 			if w, ok := pweights["default"]; ok {
    api\cmd\api\main.go: 
  Linha 536:
    api\main.go       : 				for k, v := range w {
    api\cmd\api\main.go: 
  Linha 537:
    api\main.go       : 					weights[strings.ToUpper(k)] = v
    api\cmd\api\main.go: 
  Linha 538:
    api\main.go       : 				}
    api\cmd\api\main.go: 
  Linha 539:
    api\main.go       : 			}
    api\cmd\api\main.go: 
  Linha 540:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 541:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 542:
    api\main.go       : 	if len(weights) == 0 {
    api\cmd\api\main.go: 
  Linha 543:
    api\main.go       : 		weights[from] = 0.40
    api\cmd\api\main.go: 
  Linha 544:
    api\main.go       : 		if len(alts) > 0 {
    api\cmd\api\main.go: 
  Linha 545:
    api\main.go       : 			rem := 0.60 / float64(len(alts))
    api\cmd\api\main.go: 
  Linha 546:
    api\main.go       : 			for _, a := range alts {
    api\cmd\api\main.go: 
  Linha 547:
    api\main.go       : 				weights[a] = rem
    api\cmd\api\main.go: 
  Linha 548:
    api\main.go       : 			}
    api\cmd\api\main.go: 
  Linha 549:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 550:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 551:
    api\main.go       : 	// normaliza ao conjunto solicitado
    api\cmd\api\main.go: 
  Linha 552:
    api\main.go       : 	sum := 0.0
    api\cmd\api\main.go: 
  Linha 553:
    api\main.go       : 	for _, p := range partners {
    api\cmd\api\main.go: 
  Linha 554:
    api\main.go       : 		sum += weights[p]
    api\cmd\api\main.go: 
  Linha 555:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 556:
    api\main.go       : 	if sum == 0 {
    api\cmd\api\main.go: 
  Linha 557:
    api\main.go       : 		eq := 1.0 / float64(len(partners))
    api\cmd\api\main.go: 
  Linha 558:
    api\main.go       : 		for _, p := range partners {
    api\cmd\api\main.go: 
  Linha 559:
    api\main.go       : 			weights[p] = eq
    api\cmd\api\main.go: 
  Linha 560:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 561:
    api\main.go       : 		sum = 1.0
    api\cmd\api\main.go: 
  Linha 562:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 563:
    api\main.go       : 	for k, v := range weights {
    api\cmd\api\main.go: 
  Linha 564:
    api\main.go       : 		weights[k] = v / sum
    api\cmd\api\main.go: 
  Linha 565:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 566:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 567:
    api\main.go       : 	// Tarifas (cenÃ¡rios)
    api\cmd\api\main.go: 
  Linha 568:
    api\main.go       : 	scenarioName := c.DefaultQuery("tariff_scenario", "base")
    api\cmd\api\main.go: 
  Linha 569:
    api\main.go       : 	scn, hasScenario := tariffs.Scenarios[scenarioName]
    api\cmd\api\main.go: 
  Linha 570:
    api\main.go       : 	tariffApplied := false
    api\cmd\api\main.go: 
  Linha 571:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 572:
    api\main.go       : 	type Item struct {
    api\cmd\api\main.go: 
  Linha 573:
    api\main.go       : 		Partner      string  `json:"partner"`
    api\cmd\api\main.go: 
  Linha 574:
    api\main.go       : 		Share        float64 `json:"share"`
    api\cmd\api\main.go: 
  Linha 575:
    api\main.go       : 		Factor       float64 `json:"factor"`
    api\cmd\api\main.go: 
  Linha 576:
    api\main.go       : 		EstimatedUSD float64 `json:"estimated_usd"`
    api\cmd\api\main.go: 
  Linha 577:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 578:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 579:
    api\main.go       : 	out := make([]Item, 0, len(partners))
    api\cmd\api\main.go: 
  Linha 580:
    api\main.go       : 	adjustedTotal := 0.0
    api\cmd\api\main.go: 
  Linha 581:
    api\main.go       : 	for _, p := range partners {
    api\cmd\api\main.go: 
  Linha 582:
    api\main.go       : 		share := weights[p]
    api\cmd\api\main.go: 
  Linha 583:
    api\main.go       : 		est := share * tam
    api\cmd\api\main.go: 
  Linha 584:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 585:
    api\main.go       : 		factor := 1.0
    api\cmd\api\main.go: 
  Linha 586:
    api\main.go       : 		if hasScenario {
    api\cmd\api\main.go: 
  Linha 587:
    api\main.go       : 			factor = factorFor(scn, year, chapter, p)
    api\cmd\api\main.go: 
  Linha 588:
    api\main.go       : 			if factor != 1.0 {
    api\cmd\api\main.go: 
  Linha 589:
    api\main.go       : 				tariffApplied = true
    api\cmd\api\main.go: 
  Linha 590:
    api\main.go       : 			}
    api\cmd\api\main.go: 
  Linha 591:
    api\main.go       : 		}
    api\cmd\api\main.go: 
  Linha 592:
    api\main.go       : 		est = est * factor
    api\cmd\api\main.go: 
  Linha 593:
    api\main.go       : 		adjustedTotal += est
    api\cmd\api\main.go: 
  Linha 594:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 595:
    api\main.go       : 		out = append(out, Item{
    api\cmd\api\main.go: 
  Linha 596:
    api\main.go       : 			Partner:      p,
    api\cmd\api\main.go: 
  Linha 597:
    api\main.go       : 			Share:        share,
    api\cmd\api\main.go: 
  Linha 598:
    api\main.go       : 			Factor:       factor,
    api\cmd\api\main.go: 
  Linha 599:
    api\main.go       : 			EstimatedUSD: est,
    api\cmd\api\main.go: 
  Linha 600:
    api\main.go       : 		})
    api\cmd\api\main.go: 
  Linha 601:
    api\main.go       : 	}
    api\cmd\api\main.go: 
  Linha 602:
    api\main.go       : 
    api\cmd\api\main.go: 
  Linha 603:
    api\main.go       : 	c.JSON(200, gin.H{
    api\cmd\api\main.go: 
  Linha 604:
    api\main.go       : 		"year":               year,
    api\cmd\api\main.go: 
  Linha 605:
    api\main.go       : 		"ncm_chapter":        chapter,
    api\cmd\api\main.go: 
  Linha 606:
    api\main.go       : 		"basis":              "TAM (mview)",
    api\cmd\api\main.go: 
  Linha 607:
    api\main.go       : 		"tam_total_usd":      tam,
    api\cmd\api\main.go: 
  Linha 608:
    api\main.go       : 		"from":               from,
    api\cmd\api\main.go: 
  Linha 609:
    api\main.go       : 		"alts":               alts,
    api\cmd\api\main.go: 
  Linha 610:
    api\main.go       : 		"tariff_scenario":    scenarioName,
    api\cmd\api\main.go: 
  Linha 611:
    api\main.go       : 		"tariff_applied":     tariffApplied,
    api\cmd\api\main.go: 
  Linha 612:
    api\main.go       : 		"adjusted_total_usd": adjustedTotal,
    api\cmd\api\main.go: 
  Linha 613:
    api\main.go       : 		"note":               "stub com pesos + fatores de tarifa; substituir por dados reais por parceiro em prÃ³xima onda",
    api\cmd\api\main.go: 
  Linha 614:
    api\main.go       : 		"results":            out,
    api\cmd\api\main.go: 
  Linha 615:
    api\main.go       : 	})
    api\cmd\api\main.go: 
  Linha 616:
    api\main.go       : }
    api\cmd\api\main.go: 
  Linha 617:
    api\main.go       : 
    api\cmd\api\main.go: 

Total de linhas diferentes: 614

RECOMENDAÇÃO: ⚠ REVISAR MANUALMENTE
RAZÃO: Conteúdos diferentes - verificar qual versão é correta

--------------------------------------------------------------------------------
VERIFICAÇÃO DO DOCKERFILE
--------------------------------------------------------------------------------
 OK: Dockerfile não referencia main.go na raiz diretamente
  (ou usa COPY . . que copiará tudo)

================================================================================
ARQUIVO 2: deploy\sql\migrate_0001.sql
================================================================================

STATUS: Arquivo encontrado
LOCALIZAÇÃO: C:\Users\rafae\OneDrive\Documentos\Projetos\Brasil Global Conect\bgc-app\deploy\sql\migrate_0001.sql
TAMANHO: 1066 bytes
ÚLTIMA MODIFICAÇÃO: 10/05/2025 11:03:24

--------------------------------------------------------------------------------
CONTEÚDO DE deploy\sql\migrate_0001.sql
--------------------------------------------------------------------------------
-- BGC  Migration 0001 (estrutura base)
-- Cria schemas e tabelas mínimas para ingestão e leitura

CREATE SCHEMA IF NOT EXISTS stg;
CREATE SCHEMA IF NOT EXISTS dim;
CREATE SCHEMA IF NOT EXISTS rpt;

-- Tabela de staging (cargas brutas)
CREATE TABLE IF NOT EXISTS stg.exportacao (
  id     BIGSERIAL PRIMARY KEY,
  ano    INTEGER      NOT NULL,
  setor  TEXT         NOT NULL,
  pais   TEXT         NOT NULL,
  ncm    TEXT         NOT NULL,
  valor  NUMERIC(18,2) NOT NULL,
  qtde   NUMERIC(18,3) NOT NULL DEFAULT 0
);

-- Índices úteis para leitura/aggregations
CREATE INDEX IF NOT EXISTS ix_export_ano_setor ON stg.exportacao (ano, setor);
CREATE INDEX IF NOT EXISTS ix_export_ano_pais  ON stg.exportacao (ano, pais);
CREATE INDEX IF NOT EXISTS ix_export_ncm       ON stg.exportacao (ncm);

-- Dimensões (mínimas) — opcionais, para futura normalização
CREATE TABLE IF NOT EXISTS dim.ncm (
  ncm TEXT PRIMARY KEY,
  descricao TEXT
);

CREATE TABLE IF NOT EXISTS dim.setor (
  setor TEXT PRIMARY KEY,
  descricao TEXT
);

--------------------------------------------------------------------------------
ARQUIVOS EQUIVALENTES
--------------------------------------------------------------------------------
✓ Encontrado: db\migrations\0001_init.sql

CONTEÚDO DE db\migrations\0001_init.sql:
-- Schemas
CREATE SCHEMA IF NOT EXISTS stg;
CREATE SCHEMA IF NOT EXISTS dim;

-- Staging (mínimo viável)
CREATE TABLE IF NOT EXISTS stg.exportacao (
  id BIGSERIAL PRIMARY KEY,
  ano INT NOT NULL,
  setor TEXT,
  pais TEXT,
  ncm TEXT,
  valor NUMERIC,
  qtde NUMERIC
);

CREATE TABLE IF NOT EXISTS stg.importacao (
  id BIGSERIAL PRIMARY KEY,
  ano INT NOT NULL,
  setor TEXT,
  pais TEXT,
  ncm TEXT,
  valor NUMERIC,
  qtde NUMERIC
);

-- Dimensões
CREATE TABLE IF NOT EXISTS dim.setor (
  id SERIAL PRIMARY KEY,
  nome TEXT UNIQUE NOT NULL
);

CREATE TABLE IF NOT EXISTS dim.ncm (
  id SERIAL PRIMARY KEY,
  codigo TEXT UNIQUE NOT NULL,
  descricao TEXT
);


✗ CONTEÚDOS DIFERENTES (mesmo após normalização)

 Encontrado: deploy\configmap-migrate-0001.yaml

Primeiras 20 linhas do ConfigMap:
apiVersion: v1
kind: ConfigMap
metadata:
  name: bgc-migration-0001
  namespace: data
data:
  migrate.sql: |
    -- Migration 0001: Create schemas and staging tables
    -- Schemas
    CREATE SCHEMA IF NOT EXISTS stg;
    CREATE SCHEMA IF NOT EXISTS dim;

    -- Staging (mÃ­nimo viÃ¡vel)
    CREATE TABLE IF NOT EXISTS stg.exportacao (
      id BIGSERIAL PRIMARY KEY,
      ano INT NOT NULL,
      setor TEXT,
      pais TEXT,
      ncm TEXT,
      valor NUMERIC,

--------------------------------------------------------------------------------
STATUS NO CLUSTER KUBERNETES
--------------------------------------------------------------------------------
 ConfigMap ATIVO no cluster: bgc-migration-0001

Detalhes:
Name:         bgc-migration-0001
Namespace:    data
Labels:       <none>
Annotations:  <none>

Data
====
migrate.sql:
----
-- Migration 0001: Create schemas and staging tables
-- Schemas
CREATE SCHEMA IF NOT EXISTS stg;
CREATE SCHEMA IF NOT EXISTS dim;

-- Staging (m├¡nimo vi├ível)
CREATE TABLE IF NOT EXISTS stg.exportacao (
  id BIGSERIAL PRIMARY KEY,
  ano INT NOT NULL,
  setor TEXT,
  pais TEXT,
  ncm TEXT,
  valor NUMERIC,
  qtde NUMERIC
);

CREATE TABLE IF NOT EXISTS stg.importacao (
  id BIGSERIAL PRIMARY KEY,
  ano INT NOT NULL,
  setor TEXT,
  pais TEXT,
  ncm TEXT,
  valor NUMERIC,
  qtde NUMERIC
);

-- Dimens├Áes
CREATE TABLE IF NOT EXISTS dim.setor (
  id SERIAL PRIMARY KEY,
  nome TEXT UNIQUE NOT NULL
);

CREATE TABLE IF NOT EXISTS dim.ncm (
  id SERIAL PRIMARY KEY,
  codigo TEXT UNIQUE NOT NULL,
  descricao TEXT
);



BinaryData
====

Events:  <none>

--------------------------------------------------------------------------------
RECOMENDAÇÃO FINAL
--------------------------------------------------------------------------------
 SEGURO DELETAR deploy\sql\migrate_0001.sql

RAZÕES:
   Existe equivalente em db\migrations\0001_init.sql
   Existe ConfigMap deploy\configmap-migrate-0001.yaml
   ConfigMap está ativo no cluster

O SQL em deploy\sql\ é redundante e não é usado diretamente.

================================================================================
ARQUIVO 3: deploy\sql\migrate_0002_proveniencia.sql
================================================================================

STATUS: Arquivo encontrado
LOCALIZAÇÃO: C:\Users\rafae\OneDrive\Documentos\Projetos\Brasil Global Conect\bgc-app\deploy\sql\migrate_0002_proveniencia.sql
TAMANHO: 673 bytes
ÚLTIMA MODIFICAÇÃO: 10/05/2025 11:03:24

--------------------------------------------------------------------------------
CONTEÚDO DO ARQUIVO
--------------------------------------------------------------------------------
CREATE EXTENSION IF NOT EXISTS pgcrypto;

ALTER TABLE stg.exportacao
  ADD COLUMN IF NOT EXISTS ingest_source text,
  ADD COLUMN IF NOT EXISTS ingest_at timestamptz NOT NULL DEFAULT now(),
  ADD COLUMN IF NOT EXISTS ingest_batch uuid;

-- defaults para novos inserts
ALTER TABLE stg.exportacao
  ALTER COLUMN ingest_source SET DEFAULT 'unknown',
  ALTER COLUMN ingest_batch  SET DEFAULT gen_random_uuid();

-- backfill dos registros existentes
UPDATE stg.exportacao
   SET ingest_source = COALESCE(ingest_source, 'historical'),
       ingest_batch  = COALESCE(ingest_batch, gen_random_uuid())
 WHERE ingest_source IS NULL
    OR ingest_batch  IS NULL;

--------------------------------------------------------------------------------
OBJETIVO DA MIGRATION
--------------------------------------------------------------------------------
Esta migration adiciona colunas de proveniência/auditoria à tabela stg.exportacao:
   ingest_source (TEXT) - Origem dos dados
  • ingest_at (TIMESTAMPTZ) - Data/hora da ingestão
  • ingest_batch (UUID) - ID do lote de ingestão

--------------------------------------------------------------------------------
VERIFICAÇÃO NO BANCO DE DADOS
--------------------------------------------------------------------------------
✓ Conectado ao banco - Estrutura atual da tabela stg.exportacao:

 column_name | data_type | is_nullable  -------------+-----------+-------------  id          | bigint    | NO  ano         | integer   | NO  setor       | text      | YES  pais        | text      | YES  ncm         | text      | YES  valor       | numeric   | YES  qtde        | numeric   | YES (7 rows)  pod "db-check-prov" deleted from data namespace

✗ RESULTADO: Colunas de proveniência NÃO EXISTEM no banco
  A migration ainda não foi aplicada

--------------------------------------------------------------------------------
ARQUIVOS RELACIONADOS
--------------------------------------------------------------------------------

Migrations em db\migrations\:
   0001_init.sql
   0002_add_staging_indexes.sql

✓ Encontrado: deploy\configmap-migrate-0002.yaml

 ConfigMap ativo no cluster: bgc-migrate-0002

--------------------------------------------------------------------------------
RECOMENDAÇÃO FINAL
--------------------------------------------------------------------------------
 NÃO DELETAR - MANTER OU APLICAR PRIMEIRO

RAZÃO: Migration ainda NÃO foi aplicada no banco

AÇÕES POSSÍVEIS:
  1. Aplicar a migration no banco primeiro, depois deletar o arquivo
  2. Mover para db\migrations\ se quiser manter histórico
  3. Criar ConfigMap e aplicar via Job Kubernetes

================================================================================
RESUMO EXECUTIVO E PLANO DE AÇÃO
================================================================================

DATA DA ANÁLISE: 12/10/2025 17:41:28


--------------------------------------------------------------------------------
TABELA RESUMO
--------------------------------------------------------------------------------


 ARQUIVO                                          RECOMENDAÇÃO  RAZÃO PRINCIPAL             

 api\main.go                                      REVISAR       Conteúdo diferente          
 deploy\sql\migrate_0001.sql                      DELETAR       Tem ConfigMap e migration   
 deploy\sql\migrate_0002_proveniencia.sql         MANTER        Não aplicada ainda          


--------------------------------------------------------------------------------
PLANO DE AÇÃO RECOMENDADO
--------------------------------------------------------------------------------

FASE 1 - CHECKPOINT
   Fazer commit de segurança: git commit -am 'checkpoint antes limpeza'

FASE 2 - DELETAR SEGUROS
  □ Deletar: deploy\sql\migrate_0001.sql

FASE 3 - TESTAR
  □ Verificar pods: kubectl get pods -n data
  □ Testar API: curl http://localhost:8080/healthz
  □ Testar Web: curl http://web.bgc.local

FASE 4 - COMMIT
  □ Se tudo OK: git add . && git commit -m 'chore: remove arquivos duplicados'
  □ Se problema: git reset --hard HEAD~1


--------------------------------------------------------------------------------
ARQUIVOS QUE PRECISAM ATENÇÃO ESPECIAL
--------------------------------------------------------------------------------

⚠ api\main.go
  Conteúdo diferente de api\cmd\api\main.go
  Ação: Comparar manualmente e decidir qual versão manter

⚠ deploy\sql\migrate_0002_proveniencia.sql
  Migration não aplicada no banco ainda
  Ação: Aplicar primeiro OU mover para db\migrations\


================================================================================
FIM DO RELATÓRIO
================================================================================


Relatório gerado automaticamente pelo script de análise BGC.
Para dúvidas ou mais informações, consulte a documentação do projeto.


